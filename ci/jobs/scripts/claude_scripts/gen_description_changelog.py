#!/usr/bin/env python3
import os
import re
import sys
from shlex import quote
from typing import Tuple
from pathlib import Path
from praktika.info import Info
from praktika.utils import Shell
from ci.praktika.gh import GH
from ci.praktika import Secret


def extract_autogenerated_content(filename: str) -> str:
    """LLM responses are written to .txt file by subagent and read back by this function"""
    try:
        with open(filename, "r", encoding="utf-8", errors="replace") as f:
            file_content = f.read()

        # Remove "EOF < /dev/null" if it exists
        file_content = file_content.replace("EOF < /dev/null", "")

        return file_content
    except FileNotFoundError:
        print(f"Warning: {filename} not found")
        return ""
    except Exception as e:
        print(f"Error reading {filename}: {e}")
        return ""


def ensure_claude_API_key() -> bool:
    try:
        api_key = Secret.Config(
            name="ANTHROPIC_API_KEY",
            type=Secret.Type.AWS_SSM_VAR,
        ).get_value()
        os.environ["ANTHROPIC_API_KEY"] = api_key
        print("ANTHROPIC_API_KEY secret found and set as environment variable")
        return True
    except Exception as e:
        print(f"Could not find ANTHROPIC_API_KEY secret: {e}")
        return False


def ensure_claude_code_cli() -> bool:
    try:
        Shell.run("node --version", verbose=True)
        exit_code = Shell.run("command -v claude", verbose=False)
        if exit_code == 0:
            claude_path = Shell.get_output("command -v claude").strip()
            print(f"claude-code CLI found at: {claude_path}")
            return True
        else:
            raise Exception("claude command not found")
    except:
        print("claude-code not found")
        return False

def extract_content_and_format_flag(body: str, tag_prefix: str) -> Tuple[str, bool]:
    
    """
    PR body contains:

    <!---
    The PR description will be automatically generated based on the contents of this PR
    and the description will be inserted between the BEGIN and END tags below

    1. If you wish to write your own description but have the LLM format it for you
       place it between the tags below and change the comment to format=true
    2. If you don't want any LLM help at all, you can remove the tags below
       and add your own description instead.
    -->

    <!--- BEGIN_DESCRIPTION format=false -->
    <!--- END_DESCRIPTION -->

    ...

    <!--- BEGIN: AUTOGENERATED CHANGELOG ENTRY
    The Changelog entry will be automatically generated based on the contents of this PR
    and the changelog entry will be inserted between the BEGIN and END tags below.

    1. If you wish to write your own and have the LLM format it for you, place it between
       the BEGIN and END tags below and set format=true
    2. If you don't want any LLM help at all, remove the tags below and add your changelog entry instead
    -->

    <!--- BEGIN_CHANGELOG_ENTRY format=false -->
    <!--- END_CHANGELOG_ENTRY -->
    """

    # Look for BEGIN tag which has a format attribute
    begin_pattern = f"<!--- {tag_prefix} format=(true|false) -->"
    end_pattern = f"<!--- END_{tag_prefix.split('_')[1]} -->"

    begin_match = re.search(begin_pattern, body, re.IGNORECASE)
    end_match = re.search(end_pattern, body, re.IGNORECASE)

    if begin_match and end_match:
        # Check if user wants the text between BEGIN and END tags needs
        format_flag = begin_match.group(1).lower() == "true"

        # Extract content between tags
        start = begin_match.end()
        end = end_match.start()
        content = body[start:end].strip()

        return content, format_flag
    return "", False


def insert_content_between_tags(text: str, tag_prefix: str, new_content: str) -> str:
    """
    Function to format tags with either LLM generated body (if no text between BEGIN and END tags and format=false)
    or a human written body formatted by the LLM (if there is text between BEGIN and END tags but format=true)
    """

    # Look for a BEGIN tag with the format attribute
    begin_pattern = f"<!--- {tag_prefix} format=(true|false) -->"
    end_pattern = f"<!--- END_{tag_prefix.split('_')[1]} -->"

    begin_match = re.search(begin_pattern, text, re.IGNORECASE)
    end_match = re.search(end_pattern, text, re.IGNORECASE)

    if begin_match and end_match:
        new_begin_tag = f"<!--- {tag_prefix} format=false -->"

        # Replace everything from BEGIN tag to END tag
        before = text[:begin_match.start()]
        after = text[end_match.end():]

        return f"{before}{new_begin_tag}\n{new_content}\n<!--- END_{tag_prefix.split('_')[1]} -->{after}"
    return text

def generate_description(diff_file: str, human_description: str, model: str) -> str:
    try:
        prompt = f"Use the pr-description-generator agent to generate a PR description for this PR. Read the diff from file: {diff_file}"
        # Write prompt to file and pipe it to claude to avoid shell escaping issues
        with open("prompt_description.txt", "w", encoding="utf-8") as f:
            f.write(prompt)

        command = f"cat prompt_description.txt | claude --model '{model}' --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'Generate PR description' > pr_description.txt"
        Shell.check(command)
        description = extract_autogenerated_content("pr_description.txt")
        return description
    except Exception as e:
        print(f"Error running claude command: {e}")
        return f"Error generating PR description: {e}"


def generate_changelog_entry(
    diff_file: str, human_changelog_entry: str, model: str
) -> str:
    try:
        prompt = f"Use the pr-changelog-generator agent to generate a PR changelog entry for this PR. Read the diff from file: {diff_file}"
        # Write prompt to file and pipe it to claude to avoid shell escaping issues
        with open("prompt_changelog.txt", "w", encoding="utf-8") as f:
            f.write(prompt)

        command = f"cat prompt_changelog.txt | claude --model '{model}' --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'Generate changelog entry' > changelog_entry.txt"
        Shell.check(command)
        changelog = extract_autogenerated_content("changelog_entry.txt")
        return changelog
    except Exception as e:
        print(f"Error running claude command: {e}")
        return f"Error generating changelog entry: {e}"

def format_description_or_changelog(type: str, content: str, model: str):
    if type is "description":
        try:
            with open("user_pr_description.txt", "w", encoding="utf-8") as f:
                f.write(content)
            prompt = f"Use the pr-description-formatter agent to read the user provided description stored in user_pr_description.txt and format it."

            # Write prompt to file and pipe it to claude to avoid shell escaping issues
            with open("prompt_user_description.txt", "w", encoding="utf-8") as f:
                f.write(prompt)

            command = f"cat prompt_user_description.txt | claude --model '{model}' --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'format' > formatted_user_description.txt"
            Shell.check(command)
            changelog = extract_autogenerated_content("formatted_user_description.txt")
            return changelog
        except Exception as e:
            print(f"Error running claude command: {e}")
            return f"Error formatting user description: {e}"

    elif type is "changelog":
        try:
            with open("user_changelog_entry.txt", "w", encoding="utf-8") as f:
                f.write(content)
            prompt = f"Use the pr-changelog-formatter agent to read the user provided changelog entry stored in user_changelog_entry.txt and format it."

            # Write prompt to file and pipe it to claude to avoid shell escaping issues
            with open("prompt_user_changelog.txt", "w", encoding="utf-8") as f:
                f.write(prompt)

            command = f"cat prompt_user_changelog.txt | claude --model '{model}' --output-format text --allowedTools 'Bash,Read' --permission-mode acceptEdits -p 'format' > formatted_user_changelog.txt"
            Shell.check(command)
            changelog = extract_autogenerated_content("formatted_user_changelog.txt")
            return changelog
        except Exception as e:
            print(f"Error running claude command: {e}")
            return f"Error formatting user description: {e}"
    else:
        raise Exception("No valid type was provided. Please specify either 'description' or 'changelog'")
        sys.exit(1)

def update_pr_body_with_generated_content(pr_body: str, description: str, changelog_entry: str) -> str:
    updated_body = pr_body
    updated_body = insert_content_between_tags(updated_body, "BEGIN_DESCRIPTION", description)
    updated_body = insert_content_between_tags(updated_body, "BEGIN_CHANGELOG_ENTRY", changelog_entry)

    return updated_body

def should_process_section(pr_body: str, tag_prefix: str) -> Tuple[bool, Tuple[bool, str]]:
    content, should_format = extract_content_and_format_flag(pr_body, tag_prefix)
   
    """
    Processing happens if:
    1. The BEGIN and END tags have nothing between them -> LLM generates the content
    2. The BEGIN and END tags do have content and format=true (false by default) -> Format the existing content
    
    No processing occurs if format=false and there is content between the tags i.e user written without LLM assistance
    """
    should_process = not content.strip() or should_format
    return (should_process, (should_format, content))


if __name__ == "__main__":
    info = Info()
    if not ensure_claude_code_cli() or not ensure_claude_API_key():
        sys.exit(1)

    model = "claude-3-5-haiku-20241022"

    Shell.check("gh auth status", verbose=True)
    pr_diff = GH.get_pr_diff()

    # Write the diff to a file for agent to read, so we don't run into context limits
    diff_file = "diff.txt"
    with open(diff_file, "w", encoding="utf-8") as file:
        file.write(pr_diff)
    
    # Check which sections should be processed
    should_process_description, description_params = should_process_section(info.pr_body, "BEGIN_DESCRIPTION")
    should_process_changelog, changelog_params = should_process_section(info.pr_body, "BEGIN_CHANGELOG_ENTRY")

    updated_pr_body = info.pr_body
    
    # Description processing
    if should_process_description:
        should_format, content = description_params
        updated_description = ""
        if should_format:
            updated_description = format_description_or_changelog("description", content, model)
        else:
            updated_description = generate_description(diff_file, info.pr_body, model)
        updated_pr_body = insert_content_between_tags(updated_pr_body, "BEGIN_DESCRIPTION", updated_description)
        print("Generated / formatted the PR description")
    else:
        print("Skipping PR description. Either no tags were found, or the tags have body text but format=false")

    # Changelog processing
    if should_process_changelog:
        should_format, content = changelog_params
        updated_changelog_entry = ""
        if should_format:
            updated_changelog_entry = format_description_or_changelog("changelog", content, model)
        else:
            updated_changelog_entry = generate_changelog_entry(diff_file, updated_pr_body, model)
        updated_pr_body = insert_content_between_tags(updated_pr_body, "BEGIN_CHANGELOG_ENTRY", updated_changelog_entry)
        print("Generated / formatted the PR changelog entry")
    else:
        print("Skipping PR changelog entry. Either no tags were found, or the tags have body text but format=false")

    if should_process_description or should_process_changelog:
    try:
            # Update the PR body directly
            GH.update_pr_body(updated_pr_body)
            print("Successfully updated PR body with generated content")
        except Exception as e:
            print(f"Error: Could not update PR body: {e}")
            sys.exit(1)


