import os
import re
import sys
from praktika.info import Info
from praktika.utils import Shell
from ci.praktika.gh import GH
from praktika import Secret
from typing import Tuple
from pathlib import Path

def extract_autogenerated_content(filename: str) -> str:
    """Read a file and return its contents."""
    try:
        with open(filename, 'r') as f:
            file_content = f.read()
        
        # Remove "EOF < /dev/null" if it exists
        file_content = file_content.replace("EOF < /dev/null", "")
        
        return file_content
    except FileNotFoundError:
        print(f"Warning: {filename} not found")
        return ""
    except Exception as e:
        print(f"Error reading {filename}: {e}")
        return ""

def ensure_claude_API_key(info: Info) -> bool:
    try:
        api_key = Secret.Config(
            "ANTHROPIC_API_KEY", type=Secret.Type.GH_SECRET
        ).get_value()
        if not api_key:
            print("Error: ANTHROPIC_API_KEY secret not configured")
            return False

        print("ANTHROPIC_API_KEY secret found")
        os.environ["ANTHROPIC_API_KEY"] = api_key
        print("ANTHROPIC_API_KEY secret found and set as environment variable")
        return True
    except Exception as e:
        print(f"Error: Could not access ANTHROPIC_API_KEY secret: {e}")
        return False

def ensure_claude_code_cli() -> bool:
    try:
        Shell.check("command -v claude")
        print("claude-code CLI already available")
        return True
    except:
        print("claude-code not found, installing...")
        try:
            Shell.check("npm install -g @anthropic-ai/claude-code", verbose=True)
            print("claude-code CLI installed successfully")
            return True
        except:
            print("Error: Could not install claude-code CLI")
            return False

def get_human_description_changelog(pr_body: str) -> Tuple[str, str]:
    if not pr_body:
        return "", ""

    lines = list(map(lambda x: x.strip(), pr_body.split("\n") if pr_body else []))
    lines = [re.sub(r"\s+", " ", line) for line in lines]

    description = ""
    changelog_entry = ""

    # Find changelog sections
    category_header = None
    changelog_entry_header = None
    documentation_entry_header = None

    for i, line in enumerate(lines):
        # Changelog category (leave one):
        if category_header is None and re.search(r"(?i)\*\*\s*changelog\s+category.*\*\*", line):
            category_header = i

        # Changelog entry (a user-readable short description of the changes that goes into CHANGELOG.md):
        elif re.search(r"(?i)\*\*\s*changelog\s+entry.*\*\*", line):
            changelog_entry_header = i

        # Documentation entry for user-facing changes
        elif re.search(r"(?i)\*\*\s*documentation\s+entry.*\*\*", line):
            documentation_entry_header = i
            break

    if category_header is not None:
        description_lines = []
        for i in range(category_header):
            description_lines.append(lines[i])
        description = "".join(description_lines)
    
    if changelog_entry_header is not None:
        changelog_entry_end = documentation_entry_header if documentation_entry_header is not None else len(lines)

        entry_lines.append(lines[i])

        changelog_entry = "".join(entry_lines).strip()

    return description, changelog_entry
    
def generate_description(pr_diff: str, human_description: str, model: str) -> str:
    try:
        base_prompt = "Use the pr-description-generator agent to generate a PR description for this PR with the following diff: \n\n {pr_diff}"
        prompt = ""
        if not human_description:
            prompt = base_prompt
        else:
            prompt = base_prompt + "\n\n and the following user-provided description:\n\n {human_description}"
            
        command = f"claude --allowedTools Bash --model '{model}' -p '{prompt}'"
        Shell.check(command)
        description = extract_autogenerated_content("pr_description.txt")
        return description
    except Exception as e:
        print(f"Error running claude command: {e}")
        return f"Error generating PR description: {e}"

def generate_changelog_entry(pr_diff: str, human_changelog_entry: str, model:str) -> str:
    try:
        base_prompt = f"Use the pr-changelog-generator agent to generate a PR changelog entry for this PR with the following diff: \n\n {pr_diff}"
        prompt = ""
        if not human_changelog_entry:
            prompt = base_prompt
        else:
           prompt = base_prompt + f"\n\n and the following user-provided changelog entry:\n\n {human_changelog_entry}" 
        command = f"claude --allowedTools Bash --model '{model}' -p '{prompt}'"
        Shell.check(command)
        changelog = extract_autogenerated_content("changelog_entry.txt")
        return changelog
    except Exception as e:
        print(f"Error running claude command: {e}")
        return f"Error generating changelog entry: {e}"

if __name__ == "__main__":
    info = Info()
    if not ensure_claude_code_cli() or not ensure_claude_API_key(info):
        sys.exit(1)

    model = "claude-3-5-haiku-20241022"
 
    pr_diff = GH.get_pr_diff()
    human_description, human_changelog_entry = get_human_description_changelog(info.pr_body)
    suggested_description = generate_description(pr_diff, human_description, model)
    suggested_changelog_entry = generate_changelog_entry(pr_diff, human_changelog_entry, model)
    comment_body = f"**Suggested PR description**:\n\n"
    comment_body += f"{suggested_description}\n\n"
    comment_body += "**Suggested changelog entry**:\n\n"
    comment_body += f"{suggested_changelog_entry}\n\n"

    # Update existing comment first if it doesn't exist
    if not GH.post_updateable_comment(
        comment_tags_and_bodies={"llm_generated_description_changelog": f"{comment_body}"},
        only_update=True
    ):
        # Comment doesn't exist yet, create a new one
        GH.post_updateable_comment(
            comment_tags_bodies={"llm_generated__description_changelog": f"{comment_body}"}
            only_update=False
        )

